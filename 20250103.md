## 디자인 패턴

### 디자인 패턴 이란

- 디자인 패턴이란 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것

### 싱글톤 패턴

- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- 데이터베이스 연결 모듈에 많이 사용
- 장점 : 하나의 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 비용 절감 가능

### 싱글톤 패턴의 단점

- 의존성이 높아짐
- TDD (Test Driven Development) 시 단위 테스트를 주로 하는데, 각 테스트마다 독립적인 인스턴스를 만들기 어려움
- 모듈 간의 결합을 강하게 만듬 ⇒ **의존성 주입**으로 해결 가능

### 의존성 주입

- 의존성 주입자가 메인 모듈과 하위 모듈 사이를 가로채서 메인 모듈이 간접적으로 의존성을 주입하는 방식
- 장점 : 모듈들을 쉽게 교체 가능하여 테스팅하기 쉽고 마이그레이션하기 수월
- 단점 : 모듈들이 더욱더 분리되므로 복잡성이 증가하고 런타임 페널티가 발 생
- 원칙 : 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함, 추상화에 의존해야함 (추상화는 세부 사항에 의존하지 말아야 함)

### 팩토리 패턴

- 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
- 상위 클래스가 중요한 뼈대를 결정하고 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정
- 장점 : 느슨한 결합, 더 많은 유연성, 유지보수성 증가

### 전략 패턴

- 객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 전략이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

### 옵저버 패턴

- 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴

### 자바스크립트에서의 옵저버 패턴 - 프록시 객체

- 프록시 객체 : 어떠한 대상의 기본적인 동작 (속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체
- 매개변수
    - target : 프록시할 대상
    - handler : target 동작을 가로채고 어떠한 동작을 할 것인지가 설정되어 있는 함수

```jsx
const handler = {
	get: function(target, name) {
		return name === 'name' ? `${target.a} ${target.b}` : target[name]
	}
}

const p = new Proxy({a: 'KUNDOL', b: 'IS AUMUMU ZANGIN'}, handler)
console.log(p.name) // KUNDOL IS AUMUMU ZANGIN
```

- Vue.js 3.0 이 프록시 객체와 옵저버 패턴을 이용하여 ref, reactive를 구현함

### 프록시 서버

- 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킴

### MVC 패턴

 - 모델 (Model), 뷰 (View), 컨트롤러 (Controller)로 이루어진 디자인 패턴

- 모델 : 애플리케이션의 데이터인 데이터베이스, 상수, 변수를 뜻함
- 뷰 : inputbox, checkbox, textarea 등 사용자 인터페이스 요소, 모델을 기반으로 사용자가 볼 수 있는 화면
- 컨트롤러 : 하나 이상의 모델과 하나 이상의 뷰를 있는 다리 역할을 하며 이벤트 등 메인 로직을 담당, 또한 모델과 뷰의 생명주기 관리, 각각의 구성 요소에 변경된 내용에 대해 알려줌
- 예시 : 스프링 프레임워크

### MVVM 패턴

- MVC의 C에 해당하는 컨트롤러가 뷰 모델 (view model)로 바뀐 패턴
- MVC와 달리 커맨드와 데이터 바인딩을 가짐
- 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원
- 장점 : UI를 별도의 코드 수정 없이 재사용 가능하고 단위 테스팅이 쉬움
- 예시 :  Vue.js

## 프로그래밍 패러다임

### 선언형 프로그래밍

- 무엇을 풀어내는가에 집중하는 패러다임, 프로그램은 함수로 이루어진 것이다. 라는 명제가 담인 패러다임

### 함수형 프로그래밍

- 순수 함수들을 블록으로 쌓아 로직을 구현하고 고차 함수를 통해 재사용성을 높인 프로그래밍 패러다임

### 순수 함수

- 출력이 입력에만 의존하는 함수

```jsx
const pure = (a, b) => {
	return a + b
}
```

### 고차 함수

- 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것
- 고차 함수를 쓰기 위해서는 해당 언어가 일급 객체라는 특징을 가져야 함
    - 변수나 메서드에 함수 할당 가능
    - 함수 안에 함수를 매개변수로 담을 수 있음
    - 함수가 함수를 반환할 수 있음

### 객체지향 프로그래밍

- 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식
- 단점 : 설계에 많은 시간 소요, 처리속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느림

### 객체지향 프로그래밍의 특징

- 추상화 : 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것
- 캡슐화 : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것
- 상속성 : 상위 클래스의 특징을 하위 클래스가 이어받아서 재사용하느거 추가, 확장하는 것
- 다형성 : 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것

### SOLID 원칙

- 단일 책임 원칙 (SRP) : 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙
- 개방-폐쇄 원칙 (OCP) : 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀 있어야 하는 원칙
- 리스코프 치환 원칙 (LSP) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수  있어야 하는 원칙
- 인터페이스 분리 원칙 (ISP) : 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙
- 의존 역전 원칙 (DIP) : 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙, 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야함

### 절차형 프로그래밍

- 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있는 패러다임
- 장점 : 코드의 가독성이 좋으며 실행 속도가 빠름
- 단점 : 모듈화하기가 어렵고 유지 보수성이 떨어짐
